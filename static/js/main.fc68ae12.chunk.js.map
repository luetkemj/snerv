{"version":3,"sources":["constants/action-types.js","reducers/gamelog.reducer.js","reducers/sprites.reducer.js","lib/grid/math.js","reducers/world.reducer.js","reducers/index.js","store.js","constants/world.constants.js","actions/sprite.actions.js","actions/player.actions.js","actions/world.actions.js","pages/App/index.js","serviceWorker.js","index.js"],"names":["PLAYER_MOVE","ADD_SPRITES","UPDATE_SPRITES","UPDATE_WORLD","ADD_NEW_LOG","initialState","logs","spriteIds","spritesMap","getNeighbor","s","dir","row","col","squareToId","cols","rows","layers","layerGround","layerBelow","layerAt","layerAbove","layerSky","claimedLocations","rootReducer","combineReducers","gamelogState","state","action","type","payload","spritesState","keyBy","sprites","uniq","concat","map","sprite","id","worldState","updatedLayers","cloneDeep","forEach","layer","store","configureStore","reducer","TILE_SIZE","MAP_COLS","MAP_ROWS","MAP_WIDTH","MAP_HEIGHT","nextSpriteId","updateSprites","dispatch","moveSprites","instructions","getState","item","target","newLoc","locId","existingSpriteId","existingSprite","noClip","text","health","playerMove","player","movePlayer","monsters","filter","directions","Math","floor","random","length","v","k","spriteId","App","useDispatch","useSelector","gamelog","useEffect","Array","from","x","handleKeyDown","key","includes","String","useEventListener","className","onKeyDown","style","width","height","Object","keys","transform","role","aria-label","logEntry","index","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.fc68ae12.chunk.js","sourcesContent":["export const PLAYER_MOVE = \"PLAYER_MOVE\";\n\nexport const ADD_SPRITES = \"ADD_SPRITES\";\nexport const UPDATE_SPRITES = \"UPDATE_SPRITES\";\n\nexport const UPDATE_WORLD = \"UPDATE_WORLD\";\n\nexport const ADD_NEW_LOG = \"ADD_NEW_LOG\";\n","import { ADD_NEW_LOG } from \"../constants/action-types\";\n\nconst initialState = {\n  logs: []\n};\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case ADD_NEW_LOG: {\n      return {\n        ...state,\n        logs: [action.payload, ...state.logs]\n      };\n    }\n    default:\n      return state;\n  }\n}\n","import { keyBy, uniq } from \"lodash\";\nimport { ADD_SPRITES, UPDATE_SPRITES } from \"../constants/action-types\";\n\nconst initialState = {\n  spriteIds: [],\n  spritesMap: {}\n};\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case UPDATE_SPRITES: {\n      return {\n        ...state,\n        spritesMap: {\n          ...state.spritesMap,\n          ...keyBy(action.payload.sprites, \"id\")\n        }\n      };\n    }\n\n    case ADD_SPRITES: {\n      const spriteIds = uniq(\n        state.spriteIds.concat(action.payload.map(sprite => sprite.id))\n      );\n\n      const spritesMap = {\n        ...state.spritesMap,\n        ...keyBy(action.payload, \"id\")\n      };\n\n      return {\n        ...state,\n        spriteIds,\n        spritesMap\n      };\n    }\n\n    default:\n      return state;\n  }\n}\n","import { each, keyBy, map, orderBy, uniq } from \"lodash\";\n\n// 00, 10, 20\n// 01, 11, 21\n// 02, 12, 22\n// dir\n// NW  N  NE\n// W       E\n// SW  S  SE\n// 01 col, row\n// { col: 0, row: 1 }\nexport const getNeighbor = (s, dir) => {\n  switch (dir) {\n    case \"N\":\n      return { ...s, row: s.row - 1 };\n    case \"NE\":\n      return { col: s.col + 1, row: s.row - 1 };\n    case \"E\":\n      return { ...s, col: s.col + 1 };\n    case \"SE\":\n      return { col: s.col + 1, row: s.row + 1 };\n    case \"S\":\n      return { ...s, row: s.row + 1 };\n    case \"SW\":\n      return { col: s.col - 1, row: s.row + 1 };\n    case \"W\":\n      return { ...s, col: s.col - 1 };\n    case \"NW\":\n      return { col: s.col - 1, row: s.row - 1 };\n\n    default:\n      return s;\n  }\n};\n\n// Given any 2 squares on a grid\n// return the top left square of their rectangle\n// ex: given 20 and 02 will return 00 from the square grid below\n// 00, 10, 20\n// 01, 11, 21\n// 02, 12, 22\nexport const topLeft = (s1, s2) => {\n  return {\n    col: Math.min(s1.col, s2.col),\n    row: Math.min(s1.row, s2.row)\n  };\n};\n\n// Given any 2 squares on a grid\n// return the bottom right square of their rectangle\n// ex: given 20 and 02 will return 22 from the square grid below\n// 00, 10, 20\n// 01, 11, 21\n// 02, 12, 22\nexport const bottomRight = (s1, s2) => {\n  return {\n    col: Math.max(s1.col, s2.col),\n    row: Math.max(s1.row, s2.row)\n  };\n};\n\nexport const squareToId = s => `${s.col},${s.row}`;\n\nexport const idToSquare = id => {\n  const coords = id.split(\",\");\n  return { col: parseInt(coords[0], 10), row: parseInt(coords[1], 10) };\n};\n\n// Given two squares on a grid\n// return a horizontal L->R row from the top left sq of their rectangle\nexport const getRow = (s1, s2) => {\n  const tlsq = topLeft(s1, s2);\n  const brsq = bottomRight(s1, s2);\n  const row = [];\n\n  let col = tlsq.col;\n\n  while (col <= brsq.col) {\n    row.push({ col: col, row: tlsq.row });\n    col = col + 1;\n  }\n\n  return keyBy(row, squareToId);\n};\n\n// Given two squares on a grid\n// return a vertical T->B column from the top left sq of their rectangle\nexport const getColumn = (s1, s2) => {\n  const tlsq = topLeft(s1, s2);\n  const brsq = bottomRight(s1, s2);\n  const column = [];\n\n  let row = tlsq.row;\n\n  while (row <= brsq.row) {\n    column.push({ col: tlsq.col, row });\n    row = row + 1;\n  }\n\n  return keyBy(column, squareToId);\n};\n\n// given two squares on a grid, returns all squares within their rectangle\n// ex: given 10 and 02 will return the bracketed sqaures below\n//   [00], [10],  20\n//   [01], [11],  21\n//   [02], [12],  22\nexport const getAllSquares = (s1, s2) => {\n  const tlsq = topLeft(s1, s2);\n  const brsq = bottomRight(s1, s2);\n\n  let squares = {};\n\n  const column = getColumn(tlsq, brsq);\n\n  each(column, s => (squares = { ...squares, ...getRow(s, brsq) }));\n\n  return keyBy(squares, squareToId);\n};\n\nexport const getMaxColumn = squares => {\n  return Math.max(...map(squares, s => s.col));\n};\n\nexport const getMinColumn = squares => {\n  return Math.min(...map(squares, s => s.col));\n};\n\nexport const getMaxRow = squares => {\n  return Math.max(...map(squares, s => s.row));\n};\n\nexport const getMinRow = squares => {\n  return Math.min(...map(squares, s => s.row));\n};\n\n// given a collection of squares on a grid return the rows with at least one square\nexport const getRowsInCollection = squares => {\n  return orderBy(uniq(map(squares, s => s.row)));\n};\n\n// given a collection of squares on a grid return the columns with at least one square\nexport const getColumnsInCollection = squares => {\n  return orderBy(uniq(map(squares, s => s.col)));\n};\n\n// get boundingCorners from a collection\nexport const getBoundingCorners = squares => ({\n  topLeft: `${getMinColumn(squares)},${getMinRow(squares)}`,\n  topRight: `${getMaxColumn(squares)},${getMinRow(squares)}`,\n  bottomRight: `${getMaxColumn(squares)},${getMaxRow(squares)}`,\n  bottomLeft: `${getMinColumn(squares)},${getMaxRow(squares)}`\n});\n\nexport const getUnselectedSquaresInBoundingBox = squares => {\n  const corners = getBoundingCorners(squares);\n\n  const allSquareIds = map(squares, squareToId);\n\n  const allSquaresInBoundingBox = getAllSquares(\n    idToSquare(corners.topLeft),\n    idToSquare(corners.bottomRight)\n  );\n\n  const rows = getRowsInCollection(allSquaresInBoundingBox);\n\n  const unselected = {\n    all: [],\n    rows: {}\n  };\n\n  each(rows, r => {\n    const idsInRow = map(\n      getRow(\n        { col: idToSquare(corners.topLeft).col, row: r },\n        idToSquare(corners.bottomRight)\n      ),\n      squareToId\n    );\n\n    unselected.rows[r] = [];\n\n    each(idsInRow, sId => {\n      if (!allSquareIds.includes(sId)) {\n        unselected.all.push(sId);\n        unselected.rows[r].push(sId);\n      }\n    });\n  });\n\n  return unselected;\n};\n","import { cloneDeep } from \"lodash\";\n\nimport { squareToId } from \"../lib/grid/math\";\nimport {\n  ADD_SPRITES,\n  UPDATE_SPRITES,\n  UPDATE_WORLD\n} from \"../constants/action-types\";\n\nconst initialState = {\n  cols: 60,\n  rows: 40,\n  layers: {\n    layerGround: {}, // 100\n    layerBelow: {}, // 200\n    layerAt: {}, // 300\n    layerAbove: {}, // 400\n    layerSky: {} // 500\n  },\n  claimedLocations: {}\n};\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case ADD_SPRITES: {\n      const updatedLayers = cloneDeep(state.layers);\n\n      action.payload.forEach(\n        // keyby map coords not sprite id\n        sprite => (updatedLayers[sprite.layer][squareToId(sprite)] = sprite.id)\n      );\n      return {\n        ...state,\n        layers: updatedLayers\n      };\n    }\n    case UPDATE_WORLD: {\n      return {\n        ...state,\n        layers: action.payload,\n        claimedLocations: {}\n      };\n    }\n\n    case UPDATE_SPRITES: {\n      return {\n        ...state,\n        claimedLocations: action.payload.claimedLocations\n      };\n    }\n    default:\n      return state;\n  }\n}\n","// rootReducer.js\nimport { combineReducers } from \"redux\";\n\nimport gamelogState from \"./gamelog.reducer\";\nimport spritesState from \"./sprites.reducer\";\nimport worldState from \"./world.reducer\";\n\nconst rootReducer = combineReducers({ gamelogState, spritesState, worldState });\n\nexport default rootReducer;\n","import { configureStore } from \"redux-starter-kit\";\nimport rootReducer from \"./reducers\";\n\nconst store = configureStore({\n  reducer: rootReducer\n});\n\nexport default store;\n","export const TILE_SIZE = 10; // pixels square\nexport const MAP_COLS = 10;\nexport const MAP_ROWS = 10;\n\nexport const MAP_WIDTH = MAP_COLS * TILE_SIZE;\nexport const MAP_HEIGHT = MAP_ROWS * TILE_SIZE;\n","import { filter } from \"lodash\";\n\nimport {\n  UPDATE_SPRITES,\n  ADD_SPRITES,\n  ADD_NEW_LOG\n} from \"../constants/action-types\";\nimport { MAP_COLS, MAP_ROWS } from \"../constants/world.constants\";\nimport { getNeighbor, squareToId } from \"../lib/grid/math\";\n\nlet nextSpriteId = 0;\n\nexport function addSprites(sprites) {\n  sprites.forEach(sprite => {\n    sprite.id = ++nextSpriteId;\n  });\n\n  return dispatch =>\n    dispatch({\n      type: ADD_SPRITES,\n      payload: sprites\n    });\n}\n\nexport function updateSprites(sprites, claimedLocations) {\n  return dispatch =>\n    dispatch({\n      type: UPDATE_SPRITES,\n      payload: { sprites, claimedLocations }\n    });\n}\n\n// instructions =\n// [\n//   {\n//     sprite,\n//     dir: N\n//   },\n//  ...\n// ]\nexport function moveSprites(instructions) {\n  return (dispatch, getState) => {\n    let claimedLocations = { ...getState().worldState.claimedLocations };\n\n    dispatch(\n      updateSprites(\n        instructions.map(item => {\n          const { sprite, dir } = item;\n          const { col, row } = sprite;\n          const newLoc = getNeighbor({ col, row }, dir);\n          const locId = squareToId(newLoc);\n          const layer = getState().worldState.layers[item.sprite.layer];\n          const existingSpriteId = layer[locId];\n          const existingSprite = getState().spritesState.spritesMap[\n            existingSpriteId\n          ];\n\n          // stay in bounds\n          if (newLoc.col < 0) return sprite;\n          if (newLoc.col === MAP_COLS) return sprite;\n          if (newLoc.row < 0) return sprite;\n          if (newLoc.row === MAP_ROWS) return sprite;\n\n          // don't collide with others already on the map\n          if (existingSpriteId && existingSprite.noClip) {\n            if (sprite.type !== existingSprite.type) {\n              dispatch(attack(sprite, existingSprite));\n            }\n            return sprite;\n          }\n\n          // don't move if new loc has already been claimed\n          if (claimedLocations[locId]) {\n            return sprite;\n          }\n\n          // spot is free and unclaimed. Mark it as claimed and then move there\n          claimedLocations[locId] = locId;\n          return { ...sprite, ...newLoc };\n        }),\n        claimedLocations\n      )\n    );\n  };\n}\n\nexport function movePlayer(dir) {\n  return (dispatch, getState) => {\n    const player = getState().spritesState.spritesMap[1];\n    // don't move if dead\n    if (player.health <= 0) return;\n\n    const instructions = [\n      {\n        sprite: player,\n        dir\n      }\n    ];\n\n    dispatch(moveSprites(instructions));\n  };\n}\n\nexport function moveMonsters() {\n  return (dispatch, getState) => {\n    const monsters = filter(\n      getState().spritesState.spritesMap,\n      sprite => sprite.type === \"MONSTER\" && sprite.health > 0\n    );\n\n    const directions = [\"N\", \"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\"];\n    const randomDirection = () =>\n      directions[Math.floor(Math.random() * directions.length)];\n\n    const instructions = monsters.map(sprite => ({\n      sprite,\n      dir: randomDirection()\n    }));\n\n    dispatch(moveSprites(instructions));\n  };\n}\n\nexport function attack(attacker, target) {\n  return dispatch => {\n    dispatch({ type: \"ATTACK\" });\n    if (target.type === \"MONSTER\") {\n      dispatch({\n        type: ADD_NEW_LOG,\n        payload: { text: `You attack and kill the monster!` }\n      });\n    }\n    if (target.type === \"PLAYER\") {\n      dispatch({\n        type: ADD_NEW_LOG,\n        payload: { text: `The monster kills you!` }\n      });\n    }\n    dispatch(updateSprites([{ ...target, health: 0 }]));\n  };\n}\n","import { PLAYER_MOVE } from \"../constants/action-types\";\nimport { movePlayer, moveMonsters } from \"../actions/sprite.actions\";\nimport { updateWorld } from \"../actions/world.actions\";\n\nexport function playerMove(dir) {\n  return dispatch => {\n    dispatch({ type: PLAYER_MOVE });\n    dispatch(movePlayer(dir));\n    dispatch(moveMonsters());\n    dispatch(updateWorld());\n  };\n}\n","import { forEach } from \"lodash\";\n\nimport { squareToId } from \"../lib/grid/math\";\nimport { UPDATE_WORLD } from \"../constants/action-types\";\n\n// look at all sprites in world layers and lookup their ids. from the ids recalc the layers based on locations\nexport function updateWorld() {\n  return (dispatch, getState) => {\n    const { layers } = getState().worldState;\n\n    const updatedLayers = {};\n\n    forEach(layers, (v, k) => {\n      updatedLayers[k] = {};\n\n      forEach(v, spriteId => {\n        const sprite = getState().spritesState.spritesMap[spriteId];\n        const locId = squareToId(sprite);\n        updatedLayers[k][locId] = spriteId;\n      });\n    });\n\n    dispatch({ type: UPDATE_WORLD, payload: updatedLayers });\n  };\n}\n","import { random } from \"lodash\";\nimport React, { useEffect } from \"react\";\nimport useEventListener from \"@use-it/event-listener\";\nimport { useDispatch, useSelector } from \"react-redux\";\n\nimport {\n  TILE_SIZE,\n  MAP_COLS,\n  MAP_ROWS,\n  MAP_HEIGHT,\n  MAP_WIDTH\n} from \"../../constants/world.constants\";\nimport { addSprites } from \"../../actions/sprite.actions\";\nimport { playerMove } from \"../../actions/player.actions\";\n\nimport \"./App.scss\";\n\nfunction App() {\n  const dispatch = useDispatch();\n  const spritesMap = useSelector(state => state.spritesState.spritesMap);\n  const layerAt = useSelector(state => state.worldState.layers.layerAt);\n  const gamelog = useSelector(state => state.gamelogState.logs);\n\n  // this will only run once like componentDidMount\n  useEffect(() => {\n    dispatch(\n      addSprites([\n        {\n          type: \"PLAYER\",\n          col: 2,\n          row: 2,\n          layer: \"layerAt\",\n          noClip: true,\n          health: 1\n        },\n        ...Array.from(Array(10)).map(x => ({\n          type: \"MONSTER\",\n          col: random(0, MAP_COLS - 1),\n          row: random(0, MAP_ROWS - 1),\n          layer: \"layerAt\",\n          noClip: true,\n          health: 1\n        }))\n      ])\n    );\n  }, [dispatch]);\n\n  const movePlayer = dir => {\n    dispatch(playerMove(dir));\n  };\n\n  const handleKeyDown = ({ key }) => {\n    // key bindings\n    const PLAYER_MOVE_N = [\"ArrowUp\", \"8\", \"w\"];\n    const PLAYER_MOVE_NE = [\"9\"];\n    const PLAYER_MOVE_E = [\"ArrowRight\", \"6\", \"d\"];\n    const PLAYER_MOVE_SE = [\"3\"];\n    const PLAYER_MOVE_S = [\"ArrowDown\", \"2\", \"s\"];\n    const PLAYER_MOVE_SW = [\"1\"];\n    const PLAYER_MOVE_W = [\"ArrowLeft\", \"4\", \"a\"];\n    const PLAYER_MOVE_NW = [\"7\"];\n\n    if (PLAYER_MOVE_N.includes(String(key))) {\n      movePlayer(\"N\");\n    }\n\n    if (PLAYER_MOVE_NE.includes(String(key))) {\n      movePlayer(\"NE\");\n    }\n\n    if (PLAYER_MOVE_E.includes(String(key))) {\n      movePlayer(\"E\");\n    }\n\n    if (PLAYER_MOVE_SE.includes(String(key))) {\n      movePlayer(\"SE\");\n    }\n\n    if (PLAYER_MOVE_S.includes(String(key))) {\n      movePlayer(\"S\");\n    }\n\n    if (PLAYER_MOVE_SW.includes(String(key))) {\n      movePlayer(\"SW\");\n    }\n\n    if (PLAYER_MOVE_W.includes(String(key))) {\n      movePlayer(\"W\");\n    }\n\n    if (PLAYER_MOVE_NW.includes(String(key))) {\n      movePlayer(\"NW\");\n    }\n  };\n\n  useEventListener(\"keydown\", handleKeyDown);\n\n  return (\n    <div className=\"App\">\n      <div\n        className=\"game\"\n        onKeyDown={handleKeyDown}\n        style={{\n          width: MAP_WIDTH,\n          height: MAP_HEIGHT\n        }}\n      >\n        {Object.keys(layerAt).map(key => {\n          const spriteId = layerAt[key];\n          return (\n            <span\n              key={spriteId}\n              className={`sprite ${spritesMap[spriteId].type} ${\n                spritesMap[spriteId].health < 1 ? \"dead\" : \"\"\n              }`}\n              style={{\n                width: TILE_SIZE,\n                height: TILE_SIZE,\n                transform: `translate(${spritesMap[spriteId].col *\n                  TILE_SIZE}px, ${spritesMap[spriteId].row * TILE_SIZE}px)`\n              }}\n              role=\"img\"\n              aria-label={`${spritesMap[spriteId].type}-sprite`}\n            ></span>\n          );\n        })}\n      </div>\n\n      <div className=\"gamelog\">\n        {gamelog.map((logEntry, index) => (\n          <p key={index}>{logEntry.text}</p>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport store from \"./store\";\n\nimport \"./index.scss\";\nimport App from \"./pages/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}